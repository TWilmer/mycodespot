#summary List of events supported by Oprofile on the Cortex-A9.

= Events supported by Oprofile on the Cortex-A9 =

{{{
$ sudo opcontrol --list-events

See Cortex-A9 Technical Reference Manual
Cortex A9 DDI (ARM DDI 0388E, revision r2p0)
PMNC_SW_INCR: (counter: 1, 2, 3, 4, 5, 6)
	Software increment of PMNC registers (min count: 500) 
IFETCH_MISS: (counter: 1, 2, 3, 4, 5, 6)
	Instruction fetch misses from cache or normal cacheable memory (min count: 500) 
ITLB_MISS: (counter: 1, 2, 3, 4, 5, 6)
	Instruction fetch misses from TLB (min count: 500) 
DCACHE_REFILL: (counter: 1, 2, 3, 4, 5, 6)
	Data R/W operation that causes a refill from cache or normal cacheable memory (min count: 
        500) 
DCACHE_ACCESS: (counter: 1, 2, 3, 4, 5, 6)
	Data R/W from cache (min count: 500) 
DTLB_REFILL: (counter: 1, 2, 3, 4, 5, 6)
	Data R/W that causes a TLB refill (min count: 500) 
DREAD: (counter: 1, 2, 3, 4, 5, 6)
	Data read architecturally executed (note: architecturally executed = for instructions that 
        are unconditional or that pass the condition code) (min count: 500) 
DWRITE: (counter: 1, 2, 3, 4, 5, 6)
	Data write architecturally executed (min count: 500) 
INSTR_EXECUTED: (counter: 1, 2, 3, 4, 5, 6)
	All executed instructions (min count: 500) 
EXC_TAKEN: (counter: 1, 2, 3, 4, 5, 6)
	Exception taken (min count: 500) 
EXC_EXECUTED: (counter: 1, 2, 3, 4, 5, 6)
	Exception return architecturally executed (min count: 500) 
CID_WRITE: (counter: 1, 2, 3, 4, 5, 6)
	Instruction that writes to the Context ID Register architecturally executed (min count: 
        500) 
PC_WRITE: (counter: 1, 2, 3, 4, 5, 6)
	SW change of PC, architecturally executed (not by exceptions) (min count: 500) 
PC_IMM_BRANCH: (counter: 1, 2, 3, 4, 5, 6)
	Immediate branch instruction executed (taken or not) (min count: 500) 
PC_PROC_RETURN: (counter: 1, 2, 3, 4, 5, 6)
	Procedure return architecturally executed (not by exceptions) (min count: 500) 
UNALIGNED_ACCESS: (counter: 1, 2, 3, 4, 5, 6)
	Unaligned access architecturally executed (min count: 500) 
PC_BRANCH_MIS_PRED: (counter: 1, 2, 3, 4, 5, 6)
	Branch mispredicted or not predicted. Counts pipeline flushes because of misprediction (min 
        count: 500) 
PC_BRANCH_MIS_USED: (counter: 1, 2, 3, 4, 5, 6)
	Branch or change in program flow that could have been predicted (min count: 500) 
CPU_CYCLES: (counter: 0)
	Number of CPU cycles (min count: 500) 
JAVA_BC_EXEC: (counter: 1, 2, 3, 4, 5, 6)
	Number of Java bytecodes decoded, including speculative ones (min count: 500) 
JAVA_SFTBC_EXEC: (counter: 1, 2, 3, 4, 5, 6)
	Number of software Java bytecodes decoded, including speculative ones (min count: 500) 
JAVA_BB_EXEC: (counter: 1, 2, 3, 4, 5, 6)
	Number of Jazelle taken branches executed, including those flushed due to a previous 
        load/store which aborts late (min count: 500) 
CO_LF_MISS: (counter: 1, 2, 3, 4, 5, 6)
	Number of coherent linefill requests which miss in all other CPUs, meaning that the request 
        is sent to external memory (min count: 500) 
CO_LF_HIT: (counter: 1, 2, 3, 4, 5, 6)
	Number of coherent linefill requests which hit in another CPU, meaning that the linefill 
        data is fetched directly from the relevant cache (min count: 500) 
IC_DEP_STALL: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where CPU is ready to accept new instructions but does not receive any 
        because of the instruction side not being able to provide any and the instruction cache is 
        currently performing at least one linefill (min count: 500) 
DC_DEP_STALL: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where CPU has some instructions that it cannot issue to any pipeline and 
        the LSU has at least one pending linefill request but no pending TLB requests (min count: 
        500) 
STREX_PASS: (counter: 1, 2, 3, 4, 5, 6)
	Number of STREX instructions architecturally executed and passed (min count: 500) 
STREX_FAILS: (counter: 1, 2, 3, 4, 5, 6)
	Number of STREX instructions architecturally executed and failed (min count: 500) 
DATA_EVICT: (counter: 1, 2, 3, 4, 5, 6)
	Number of eviction requests due to a linefill in the data cache (min count: 500) 
ISS_NO_DISP: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where the issue stage does not dispatch any instruction (min count: 500) 
ISS_EMPTY: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where the issue stage is empty (min count: 500) 
INS_RENAME: (counter: 1, 2, 3, 4, 5, 6)
	Number of instructions going through the Register Renaming stage (min count: 500) 
PRD_FN_RET: (counter: 1, 2, 3, 4, 5, 6)
	Number of procedure returns whose condition codes do not fail, excluding all exception 
        returns (min count: 500) 
INS_MAIN_EXEC: (counter: 1, 2, 3, 4, 5, 6)
	Number of instructions being executed in main execution pipeline of the CPU, the multiply 
        pipeline and the ALU pipeline (min count: 500) 
INS_SND_EXEC: (counter: 1, 2, 3, 4, 5, 6)
	Number of instructions being executed in the second execution pipeline (ALU) of the CPU 
        (min count: 500) 
INS_LSU: (counter: 1, 2, 3, 4, 5, 6)
	Number of instructions being executed in the Load/Store unit (min count: 500) 
INS_FP_RR: (counter: 1, 2, 3, 4, 5, 6)
	Number of floating-point instructions going through the Register Rename stage (min count: 
        500) 
INS_NEON_RR: (counter: 1, 2, 3, 4, 5, 6)
	Number of NEON instructions going through the Register Rename stage (min count: 500) 
STALL_PLD: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where CPU is stalled because PLD slots are all full (min count: 500) 
STALL_WRITE: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where CPU is stalled because data side is full and executing writes to 
        external memory (min count: 500) 
STALL_INS_TLB: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where CPU is stalled because of main TLB misses on requests issued by the 
        instruction side (min count: 500) 
STALL_DATA_TLB: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where CPU is stalled because of main TLB misses on requests issued by the 
        data side (min count: 500) 
STALL_INS_UTLB: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where CPU is stalled because of micro TLB misses on the instruction side 
        (min count: 500) 
STALL_DATA_ULTB: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where CPU is stalled because of micro TLB misses on the data side (min 
        count: 500) 
STALL_DMB: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles where CPU is stalled due to executed of a DMB memory barrier (min count: 
        500) 
CLK_INT_EN: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles during which the integer core clock is enabled (min count: 500) 
CLK_DE_EN: (counter: 1, 2, 3, 4, 5, 6)
	Number of cycles during which the Data Engine clock is enabled (min count: 500) 
INS_ISB: (counter: 1, 2, 3, 4, 5, 6)
	Number of ISB instructions architecturally executed (min count: 500) 
INS_DSB: (counter: 1, 2, 3, 4, 5, 6)
	Number of DSB instructions architecturally executed (min count: 500) 
INS_DMB: (counter: 1, 2, 3, 4, 5, 6)
	Number of DMB instructions speculatively executed (min count: 500) 
EXT_IRQ: (counter: 1, 2, 3, 4, 5, 6)
	Number of external interrupts executed by the processor (min count: 500) 
PLE_CL_REQ_CMP: (counter: 1, 2, 3, 4, 5, 6)
	PLE cache line request completed (min count: 500) 
PLE_CL_REQ_SKP: (counter: 1, 2, 3, 4, 5, 6)
	PLE cache line request skipped (min count: 500) 
PLE_FIFO_FLSH: (counter: 1, 2, 3, 4, 5, 6)
	PLE FIFO flush (min count: 500) 
PLE_REQ_COMP: (counter: 1, 2, 3, 4, 5, 6)
	PLE request completed (min count: 500) 
PLE_FIFO_OF: (counter: 1, 2, 3, 4, 5, 6)
	PLE FIFO overflow (min count: 500) 
PLE_REQ_PRG: (counter: 1, 2, 3, 4, 5, 6)
	PLE request programmed (min count: 500) 

}}}